// There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
//
// You are giving candies to these children subjected to the following requirements:
//
// Each child must have at least one candy.
// Children with a higher rating get more candies than their neighbors.
// Return the minimum number of candies you need to have to distribute the candies to the children.

use std::fs;
use std::path::Path;
use std::usize;

const DATA_FOLDER: &str = "data";
const FOLDER_SPLIT: &str = "/";
const WHITESPACE: &str = " ";

fn i32_to_usize(i: i32) -> usize {
    if i <= 0 {
        0
    } else {
        i as usize
    }
}

fn read_data_from_name(file_name: &str) -> String {
    let path = DATA_FOLDER.to_owned() + FOLDER_SPLIT + file_name;
    fs::read_to_string(Path::new(&path))
        .expect(&format!("data parse fail, looking for {file_name}"))
}

fn main() {
    let mut example = Vec::new();

    for word in read_data_from_name("large-data.txt").split_whitespace() {
        example.push(word.parse().unwrap());
    }

    dbg!(candy(example));
}

pub fn candy(ratings: Vec<i32>) -> i32 {
    layered_increase_strategy(ratings)
}

fn layered_increase_strategy(ratings: Vec<i32>) -> i32 {
    let mut candies = vec![1; ratings.len()];

    let mut ignore_list = vec![false; ratings.len()];

    let mut x = 0;
    'outer: loop {
        x += 1;
        let mut edited = false;

        for (index, rate) in ratings.iter().enumerate() {
            if !ignore_list[index] {
                let l_rate: &i32 = &ratings.get(i32_to_usize(index as i32 - 1)).unwrap_or(&-1);
                let r_rate: &i32 = &ratings.get(i32_to_usize(index as i32 + 1)).unwrap_or(&-1);

                if rate > l_rate && *l_rate != -1 && candies[index - 1] >= candies[index] {
                    candies[index] += 1;
                    edited = true;
                }

                if rate > r_rate && *r_rate != -1 && candies[index + 1] >= candies[index] {
                    candies[index] += 1;
                    edited = true;
                }

                if edited == false {
                    ignore_list[index] = true;
                }
            }
        }

        if edited == false {
            break 'outer;
        }
    }
    dbg!(x);

    candies.iter().sum()
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_candy() {
        assert_eq!(candy(vec![1, 0, 2]), 5);
    }

    #[test]
    fn test_candy_2() {
        assert_eq!(candy(vec![1, 2, 2]), 4);
        //                    1  2, 1
    }

    #[test]
    fn test_candy_3() {
        assert_eq!(candy(vec![29, 51, 87, 87, 72, 12]), 12);
    }
}
